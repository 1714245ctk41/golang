package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"

	//"os"
	// "io"
	"log"
	"net/http"

	"github.com/PuerkitoBio/goquery"

	//"reflect"
	"strings"

	"github.com/gocolly/colly/v2"
	//"encoding/json"
	//"strconv"
)

var linkFile = "./pkg/utils/vascara_json/"

//get data total
func GetDataVascara() {

	GetProductReview()

	GetProductDetail()

	BestSaleHandle()

}
func removeDuplicate(data []model.ProductDetail) []model.ProductDetail {
	for i := 0; i < len(data)-1; i++ {
		for j := i + 1; j < len(data); j++ {
			if data[i].ID == data[j].ID {
				data[j].ID = -1
			}
		}
	}
	newData := []model.ProductDetail{}
	for _, v := range data {
		if v.ID != -1 {
			newData = append(newData, v)
		}
	}
	return newData
}

//* bestsale handle
func BestSaleHandle() {
	data := ReadJSONDe("productDetails_ver2")

	titleGroup := []string{}
	collector := colly.NewCollector()
	collector.OnHTML(".list-product .product-item", func(element *colly.HTMLElement) {
		title := element.ChildText(".product-title a")
		titleGroup = append(titleGroup, title)

	})
	collector.OnRequest(func(request *colly.Request) {
		fmt.Println("Visiting ", request.URL.String())
	})

	collector.Visit("https://www.vascara.com/best-sale?src=bestsale-homepage")

	for i, v := range data {
		for _, x := range titleGroup {
			if strings.Contains(v.Title, x) {
				data[i].BestSale = true
				break
			}
		}
	}
	fmt.Println(len(data))
	writeJSONDetail(data, "productDetails_ver2")

}

//* get product detail
func GetProductDetail() {
	data := []model.ProductDetail{}
	productViews := readJSONRe("productPreviewChild")
	for _, v := range productViews {
		data = append(data, productDetailVascava(v.Detaillink))
	}
	data = removeDuplicate(data)

	writeJSONDetail(data, "productDetails_ver2")
	fmt.Println(len(data))
}

func productDetailVascava(url string) model.ProductDetail {

	collector := colly.NewCollector()
	productDetailChild := model.ProductDetail{}
	collector.OnHTML(".detail-product .container", func(element *colly.HTMLElement) {
		productDetailChild = model.ProductDetail{
			ProductCode: element.ChildAttr("#productCode", "value"),
			Title:       element.ChildText(".title-product"),
			Image:       element.ChildAttr(".item img", "src"),
			Discount:    element.ChildText(".percent-discount"),
			Currency:    element.ChildTexts(".price .currency")[0],
		}

		idStr := element.ChildAttr("#productId", "value")
		idInt, err := strconv.Atoi(idStr)
		if err != nil {
			fmt.Println(err)
		}
		productDetailChild.ID = idInt
		price := element.ChildTexts(".price .amount")[0]
		price = strings.Replace(price, ".", "", -1)
		priceInt, err := strconv.ParseInt(price, 10, 64)
		if err != nil {
			panic(err)
		}
		productDetailChild.Price = priceInt
		inforso := element.ChildTexts(".list-oppr span")
		inforStr := ""
		for i, v := range inforso {
			if i%2 != 0 {
				inforStr += v + "||"
			} else {
				inforStr += v + "|"
			}
		}
		inforStr = strings.Replace(inforStr, "\u0026", "và ", -1)
		productDetailChild.Infor = inforStr
	})
	collector.OnHTML(".breadcrumb", func(element *colly.HTMLElement) {
		content := element.ChildTexts("a")
		productDetailChild.CategoryName = content[len(content)-1]
		productDetailChild.CategoryName = strings.Replace(productDetailChild.CategoryName, "\u0026", "và", -1)

		categoryChild := readJSON("categoryChild")
		for _, v := range categoryChild {
			if strings.Contains(v.Name, productDetailChild.CategoryName) {
				productDetailChild.CategoryId = v.Id
			}
		}
	})

	collector.OnRequest(func(request *colly.Request) {
		fmt.Println("Visiting ", request.URL.String())
	})

	collector.Visit(url)
	return productDetailChild

	// writeJSON(allFacts)

	// enc := json.NewEncoder(os.Stdout)
	// // fmt.Println(enc)
	// enc.SetIndent("", "_")
	// enc.Encode(productDetailChild)
}

//* get number Product
func GetNumberProduct(url string) int {
	collector := colly.NewCollector()
	numberPr := 0
	collector.OnHTML(".page-content .cate-view-more", func(element *colly.HTMLElement) {
		numberStr := element.ChildText(".viewmore-totalitem")
		numberStr = strings.Trim(numberStr, " ")
		number, err := strconv.Atoi(numberStr)
		if err != nil {
			fmt.Println(err)
			os.Exit(2)
		}
		numberPr = number
	})

	collector.OnRequest(func(request *colly.Request) {
		fmt.Println("Visiting ", request.URL.String())
	})

	collector.Visit(url)
	return numberPr

}

//* get productView
func GetProductReview() {
	data := []model.ProductView{}
	categories := readJSON("categoryChild")
	for _, v := range categories {
		numPro := GetNumberProduct(v.LinkCategory) + 21
		x := numPro % 21
		y := numPro / 21
		if x > 0 {
			y = y + 1
		}
		url := v.Link
		for i := 1; i <= y; i++ {
			if i > 1 {
				url = strings.Replace(url, "page="+strconv.Itoa(i-1), "page="+strconv.Itoa(i), 1)
			}
			data = append(data, productVascava(url)...)
			fmt.Println(url)

		}

		fmt.Println("_______________________________")
		fmt.Printf("page: %v", y)
		fmt.Println()
		fmt.Println(len(data))
		fmt.Println("_______________________________")

	}
	writeJSON(data, "productPreviewChild")
}

func productVascava(url string) []model.ProductView {
	productView := make([]model.ProductView, 0)
	getDataAPI := getDataAPI(url)

	// Load the HTML document
	doc, err := goquery.NewDocumentFromReader(getDataAPI)
	if err != nil {
		log.Fatal(err)
	}

	// Find the review items
	doc.Find(".product-item").Each(func(i int, s *goquery.Selection) {
		image, ok := s.Find(".avatar img").First().Attr("src")
		detaillink, ok := s.Find(".product-title a").First().Attr("href")
		if !ok {
			fmt.Println("failed find data attr")
		}
		title := s.Find(".product-title a").First().Text()

		title = strings.Trim(title, "\n")
		title = strings.Trim(title, " ")

		productVieChild := model.ProductView{
			Image:      image,
			Price:      s.Find(".amount").First().Text(),
			Currency:   s.Find(".currency").First().Text(),
			Title:      title,
			Detaillink: detaillink,
		}
		productView = append(productView, productVieChild)
	})
	// writeJSON(allFacts)
	return productView

}

func getDataAPI(url string) *strings.Reader {
	dataSource := GetDataAPI(url)
	data := model.Source{}
	jsonErr := json.Unmarshal(dataSource, &data)
	if jsonErr != nil {
		log.Fatal(jsonErr)
	}
	newReader := strings.NewReader(data.Html)
	return newReader
}

// working with json file
//productDetail
func ReadJSONDe(nameFile string) []model.ProductDetail {
	// Open our jsonFile
	jsonFile, err := os.Open(linkFile + nameFile + ".json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var result []model.ProductDetail
	json.Unmarshal([]byte(byteValue), &result)
	return result
}

//productReview
func readJSONRe(nameFile string) []model.ProductView {
	// Open our jsonFile
	jsonFile, err := os.Open(linkFile + nameFile + ".json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var result []model.ProductView
	json.Unmarshal([]byte(byteValue), &result)
	return result
}

//category
func readJSON(nameFile string) []model.Category {
	// Open our jsonFile
	jsonFile, err := os.Open(linkFile + nameFile + ".json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var result []model.Category
	json.Unmarshal([]byte(byteValue), &result)
	return result
}

func writeJSON(data []model.ProductView, nameFile string) {
	file, err := json.MarshalIndent(data, "", " ")
	if err != nil {
		log.Println("Unable to create json file")
		return
	}

	_ = ioutil.WriteFile(linkFile+nameFile+".json", file, 0644)
}
func writeJSONDetail(data []model.ProductDetail, nameFile string) {
	file, err := json.MarshalIndent(data, "", " ")
	if err != nil {
		log.Println("Unable to create json file")
		return
	}

	_ = ioutil.WriteFile(linkFile+nameFile+".json", file, 0644)
}

func GetDataAPI(url string) []byte {
	res, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	body, err := ioutil.ReadAll(res.Body)
	defer res.Body.Close()
	if res.StatusCode > 299 {
		log.Fatalf("Response failed with status code: %d and\nbody: %s\n", res.StatusCode, body)
	}
	if err != nil {
		log.Fatal(err)
	}
	// dataToStr := string(body[:])

	//var result map[string]interface{}
	return body

}
