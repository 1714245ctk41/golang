package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"

	//"os"
	// "io"
	"log"
	"net/http"

	"github.com/PuerkitoBio/goquery"

	//"reflect"
	"strings"

	"github.com/gocolly/colly/v2"
	//"encoding/json"
	//"strconv"
)

var linkFile = "./"

//get data total
func GetDataVascara() {

	// GetProductReview()

	GetProductDetail()

	BestSaleHandle()

}
func removeDuplicate(data []ProductDetail) []ProductDetail {
	for i := 0; i < len(data)-1; i++ {
		for j := i + 1; j < len(data); j++ {
			if data[i].ID == data[j].ID {
				data[j].ID = -1
			}
		}
	}
	newData := []ProductDetail{}
	for _, v := range data {
		if v.ID != -1 {
			newData = append(newData, v)
		}
	}
	return newData
}

//* bestsale handle
func BestSaleHandle() {
	data := ReadJSONDe("productDetails_ver2")

	titleGroup := []string{}
	collector := colly.NewCollector()
	collector.OnHTML(".list-product .product-item", func(element *colly.HTMLElement) {
		title := element.ChildText(".product-title a")
		titleGroup = append(titleGroup, title)

	})
	collector.OnRequest(func(request *colly.Request) {
		fmt.Println("Visiting ", request.URL.String())
	})

	collector.Visit("https://www.vascara.com/best-sale?src=bestsale-homepage")

	for i, v := range data {
		for _, x := range titleGroup {
			if strings.Contains(v.Title, x) {
				data[i].BestSale = true
				break
			}
		}
	}
	fmt.Println(len(data))
	writeJSONDetail(data, "productDetails_ver2")

}

//* get product detail
func GetProductDetail() {
	data := []ProductDetail{}
	productViews := readJSONRe("productPreviewChild")
	// for _, v := range productViews {
	// 	data = append(data, productDetailVascava(v.Detaillink))
	// }
	data = append(data, productDetailVascava(productViews)...)
	fmt.Println(len(data))

	data = removeDuplicate(data)

	writeJSONDetail(data, "productDetails_ver2")
	fmt.Println(len(data))
}

func productDetailVascava(url []ProductView) []ProductDetail {

	collector := colly.NewCollector(
		colly.CacheDir("./cache"),
	)
	// detailProduct := collector.Clone()
	productDetails := []ProductDetail{}

	productDetailChild := ProductDetail{}

	collector.OnHTML(".page-content", func(element *colly.HTMLElement) {
		productDetailChild = ProductDetail{
			ProductCode: element.ChildAttr("#productCode", "value"),
			Title:       element.ChildText(".title-product"),
			Image:       element.ChildAttr(".item img", "src"),
			Discount:    element.ChildText(".product-info .percent-discount"),
			Currency:    element.ChildTexts(".price .currency")[0],
		}

		idStr := element.ChildAttr("#productId", "value")
		idInt, err := strconv.Atoi(idStr)
		if err != nil {
			fmt.Println(err)
		}
		productDetailChild.ID = idInt
		price := element.ChildTexts(".price .amount")[0]
		price = strings.Replace(price, ".", "", -1)
		priceInt, err := strconv.ParseInt(price, 10, 64)
		if err != nil {
			panic(err)
		}
		productDetailChild.Price = priceInt
		inforso := element.ChildTexts(".list-oppr span")
		inforStr := ""
		for i, v := range inforso {
			if i%2 != 0 {
				inforStr += v + "||"
			} else {
				inforStr += v + "|"
			}
		}
		inforStr = strings.Replace(inforStr, "\u0026", "và ", -1)
		productDetailChild.Infor = inforStr
		content := element.ChildTexts(".breadcrumb a")
		productDetailChild.CategoryName = content[len(content)-1]
		productDetailChild.CategoryName = strings.Replace(productDetailChild.CategoryName, "\u0026", "và", -1)

		categoryChild := readJSON("categoryChild")
		for _, v := range categoryChild {
			if strings.Contains(v.Name, productDetailChild.CategoryName) {
				productDetailChild.CategoryId = v.Id
			}
		}
		productDetails = append(productDetails, productDetailChild)
	})

	collector.OnRequest(func(r *colly.Request) {
		fmt.Println("Visiting", r.URL.String())

	})

	for _, v := range url {
		collector.Visit(v.Detaillink)
	}
	collector.Wait()
	// collector.Visit("https://www.vascara.com/")

	return productDetails

	// writeJSON(allFacts)

	// enc := json.NewEncoder(os.Stdout)
	// // fmt.Println(enc)
	// enc.SetIndent("", "_")
	// enc.Encode(productDetailChild)
}

//* get number Product
func GetNumberProduct(url string) int {
	collector := colly.NewCollector()
	numberPr := 0
	collector.OnHTML(".page-content .cate-view-more", func(element *colly.HTMLElement) {
		numberStr := element.ChildText(".viewmore-totalitem")
		numberStr = strings.Trim(numberStr, " ")
		number, err := strconv.Atoi(numberStr)
		if err != nil {
			fmt.Println(err)
			os.Exit(2)
		}
		numberPr = number
	})

	collector.OnRequest(func(request *colly.Request) {
		fmt.Println("Visiting ", request.URL.String())
	})

	collector.Visit(url)
	return numberPr

}

//* get productView
func GetProductReview() {
	data := []ProductView{}
	categories := readJSON("categoryChild")
	for _, v := range categories {
		numPro := GetNumberProduct(v.LinkCategory) + 21
		x := numPro % 21
		y := numPro / 21
		if x > 0 {
			y = y + 1
		}
		url := v.Link
		for i := 1; i <= y; i++ {
			if i > 1 {
				url = strings.Replace(url, "page="+strconv.Itoa(i-1), "page="+strconv.Itoa(i), 1)
			}
			data = append(data, productVascava(url)...)
			fmt.Println(url)

		}

		fmt.Println("_______________________________")
		fmt.Printf("page: %v", y)
		fmt.Println()
		fmt.Println(len(data))
		fmt.Println("_______________________________")

	}
	writeJSON(data, "productPreviewChild")
}

func productVascava(url string) []ProductView {
	productView := make([]ProductView, 0)
	getDataAPI := getDataAPI(url)

	// Load the HTML document
	doc, err := goquery.NewDocumentFromReader(getDataAPI)
	if err != nil {
		log.Fatal(err)
	}

	// Find the review items
	doc.Find(".product-item").Each(func(i int, s *goquery.Selection) {
		image, ok := s.Find(".avatar img").First().Attr("src")
		detaillink, ok := s.Find(".product-title a").First().Attr("href")
		if !ok {
			fmt.Println("failed find data attr")
		}
		title := s.Find(".product-title a").First().Text()

		title = strings.Trim(title, "\n")
		title = strings.Trim(title, " ")

		productVieChild := ProductView{
			Image:      image,
			Price:      s.Find(".amount").First().Text(),
			Currency:   s.Find(".currency").First().Text(),
			Title:      title,
			Detaillink: detaillink,
		}
		productView = append(productView, productVieChild)
	})
	// writeJSON(allFacts)
	return productView

}

func getDataAPI(url string) *strings.Reader {
	dataSource := GetDataAPI(url)
	data := Source{}
	jsonErr := json.Unmarshal(dataSource, &data)
	if jsonErr != nil {
		log.Fatal(jsonErr)
	}
	newReader := strings.NewReader(data.Html)
	return newReader
}

// working with json file
//productDetail
func ReadJSONDe(nameFile string) []ProductDetail {
	// Open our jsonFile
	jsonFile, err := os.Open(linkFile + nameFile + ".json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var result []ProductDetail
	json.Unmarshal([]byte(byteValue), &result)
	return result
}

//productReview
func readJSONRe(nameFile string) []ProductView {
	// Open our jsonFile
	jsonFile, err := os.Open(linkFile + nameFile + ".json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var result []ProductView
	json.Unmarshal([]byte(byteValue), &result)
	return result
}

//category
func readJSON(nameFile string) []Category {
	// Open our jsonFile
	jsonFile, err := os.Open(linkFile + nameFile + ".json")
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var result []Category
	json.Unmarshal([]byte(byteValue), &result)
	return result
}

func writeJSON(data []ProductView, nameFile string) {
	file, err := json.MarshalIndent(data, "", " ")
	if err != nil {
		log.Println("Unable to create json file")
		return
	}

	_ = ioutil.WriteFile(linkFile+nameFile+".json", file, 0644)
}
func writeJSONDetail(data []ProductDetail, nameFile string) {
	file, err := json.MarshalIndent(data, "", " ")
	if err != nil {
		log.Println("Unable to create json file")
		return
	}

	_ = ioutil.WriteFile(linkFile+nameFile+".json", file, 0644)
}

func GetDataAPI(url string) []byte {
	res, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	body, err := ioutil.ReadAll(res.Body)
	defer res.Body.Close()
	if res.StatusCode > 299 {
		log.Fatalf("Response failed with status code: %d and\nbody: %s\n", res.StatusCode, body)
	}
	if err != nil {
		log.Fatal(err)
	}
	// dataToStr := string(body[:])

	//var result map[string]interface{}
	return body

}

type ProductDetail struct {
	ID           int    `json:"id"`
	ProductCode  string `json:"productcode"`
	Title        string `json:"title"`
	CategoryName string `json:"categoryname"`
	CategoryId   int    `json:"categoryid"`
	Image        string `json:"image"`
	Discount     string `json:"discount"`
	Price        int64  `json:"price"`
	Currency     string `json:"currency"`
	BestSale     bool   `json:"bestsale"`
	Infor        string `json:"infor"`
}

type ProductView struct {
	Image      string `json:"image"`
	Price      string `json:"price"`
	Currency   string `json:"currency"`
	Title      string `json:"title"`
	Detaillink string `json:"detaillink"`
}
type Category struct {
	Id           int    `json:"id"`
	IdFa         int    `json:"idfa"`
	Name         string `json:"title"`
	Link         string `json:"link"`
	LinkCategory string `json:"linkcategory"`
}
type Source struct {
	Html string `json:"html"`
}
